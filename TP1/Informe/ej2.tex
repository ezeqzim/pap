\section{Ejercicio 2}

\subsection{El Problema}

El problema toma como entrada un conjunto P de $N$ personas y una matriz M de $N \times N$, tal que $M_{ij}$ almacena que tan bien se llevan $P_i$ con $P_j$.

Un valor negativo implica que se llevan mal, cero que les es indistinto y positivo que se llevan bien. Vale que $M_{ii} = 0$ $1 \leq i \leq N$ y $M_{ij} = M_{ji}$  $1 \leq i, j \leq N$. Es decir que M es sim\'etrica y con diagonal nula. 

Interesa construir una partici\'on de $P = \bigcup\limits_{i = 1}^{N} A_i$, tal que para cada par $1 \leq i, j \leq N$ $i \neq j$, $A_i \cap A_j = \emptyset$, \textbf{sin} la condici\'on $A_i \neq \emptyset$

El objetivo del problema es maximizar $\displaystyle\sum_{k = 1}^{N} valor(A_k)$ donde $valor(A_k)$ es igual a $\displaystyle\sum_{i,j = 1, P_i, P_j \in A_k}^{N} M_{ij}$

\subsection{Desarrollo}

Representaremos a los conjuntos con un entero \textit{mask}, cuya representaci\'on en binario indica que si el bit i-\'esimo es un $1$ entonces $P_i \in mask_i$.

La soluci\'on consiste en calcular, para cada elemento del conjunto de partes de P, la suma de los $M_{ij}$ correspondientes. Luego buscamos la partici\'on que cumpla el requisito de la secci\'on anterior.

La funci\'on funScore realiza lo pedido, esto es el m\'aximo entre:

\begin{itemize}
	\item $0 \rightarrow N$ subconjuntos.
	\item valor(conjunto) $\rightarrow 1$ subconjunto.
	\item ($\forall subconjunto \in conjunto$) score(subconjunto) + score(complemento(subconjunto)) $\rightarrow 2$ a $N-1$ subconjuntos.
\end{itemize}

\subsubsection{Implementaci√≥n}

\begin{verbatim}
vector<vector<int> > matrix; // Guardar los datos de entrada
vector<pair<bool, int> > fun; // bool = calculado?, int = score
\end{verbatim}

\begin{verbatim}
int setToScore(int N, int mask){
  int sum = 0; // O(1)
  forn(i, N) // O(N)
    if((1<<i) == (mask&(1<<i))) // O(1)
      forr(j, i+1, N) // O(N)
        if((1<<j) == (mask&(1<<j))) // O(1)
          sum += matrix[i][j]; // O(1)
  return sum; // O(1)
}
\end{verbatim}

\begin{verbatim}
int funScore(int N, int mask){
  if(fun[mask].first)
    return fun[mask].second;
  int res = 0, mask_score = setToScore(N, mask);
  for(int i = mask&(mask-1); i != 0; i = mask&(i-1))
    res = max(res, funScore(N, mask^i) + funScore(N, i));
  res = max(res, mask_score);
  fun[mask] = pair<bool, int>(true, res);
  return res;
}
\end{verbatim}

\begin{verbatim}
int main(int argc, char const *argv[]) {
  int N; // O(1)
  cin >> N; // O(1)
  matrix.resize(N, vector<int>(N)); // O(N^2)
  forn(i, N) // O(N)
    forn(j, N) // O(N)
      cin >> matrix[i][j]; // O(1)

  fun.resize(1<<N, pair<bool, int>(false, 0)); // O(2^N)
  fun[0] = pair<bool, int>(true, 0); // O(1)
  cout << funScore(N, (1<<N) - 1) << endl; // O(3^N)
  return 0;
}
\end{verbatim}

\subsubsection{Complejidad}

En este apartado analizaremos la complejidad de las funciones \textit{main}, \textit{funScore} y \textit{setToScore}

\begin{itemize}
	\item \textbf{main}: La funci\'on lee la entrada, el entero $N$, luego $N^2$ enteros, inicializa el memo \textit{fun}, que tiene $O(2^N)$ posiciones. Luego llama a la funci\'on funScore $O(3^N)$. La complejidad es entonces $O(1 + N^2 + 2^N + 3^N)$ que es igual a $O(3^N)$.

	\item \textbf{funScore}: La funci\'on calcula el score de mask $O(N^2)$., luego itera sobre los subconjuntos calculando la suma de su score con el del complemento en forma recursiva, y se queda con el m\'aximo entre ellos.
	Cabe destacar que para cada subconjunto posible, se llama solo una vez a la funci\'on setToScore, dado que se memoizan los resultados. En total son $O(2^N)$ subconjuntos, sumado a la iteraci\'on sobre los subconjuntos de \textit{mask}, se puede demostrar que la complejidad final es de $O(3^N)$.

	\item \textbf{setToScore}: La funci\'on hace un for de 0 a N que realiza otro for de i+1 a N. Las dem\'as operaciones son $O(1)$. Esto da como resultado una complejidad de $O(N^2)$.
\end{itemize}
