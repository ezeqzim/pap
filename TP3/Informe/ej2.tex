\section{Ejercicio 2}
\subsection{El Problema}
Dadas $S_1,...,S_A$ cadenas distintas, y dado $D_i$ el prefijo de la subcadena $S_i$ (de tamaño arbitrario), el problema consiste en encontrar 
\begin{gather*}
T = \operatorname*{max}_{i = 1,...,A} (\Phi(D_i))\text{, donde}\\
\Phi(D_k) = \text{Cantidad de cadenas $S_i$ que tienen a $D_k$ como prefijo}
\end{gather*}

\subsection{Desarrollo}
Para resolver el problema, se implementó un \emph{Trie}.\\
Un \emph{Trie} es un árbol donde cada camino desde la raíz hasta un nodo representa una cadena. Por lo tanto, el nodo raíz representa la cadena vacía, y dado un nodo cualquiera que representa a la cadena $R$, todos sus hijos representaran cadenas de la forma $R' = Ry$, es decir, $R'$ tiene a $R$ como prefijo.\\
A su vez, se guardó en cada nodo $i$, la cantidad de cadenas $C_i$ que tienen como prefijo la cadena representada por dicho nodo.\\
Al agregar una palabra, como se sabe que no existen dos palabras iguales, se debe incrementar en uno el $C_i$ de cada nodo visitado al insertar la palabra nueva. 
%Para lograr esto, al insertar cada cadena y sabiendo que son distintas, cada nodo involucrado incrementa su $C_i$, esto es, los nodos correspondientes a la cadena agregada.\\
De esta manera, hallar $T$ es equivalente a hallar $\displaystyle Q = \operatorname*{max}_{i \in Terminales} (C_i)$, donde $Terminales$ es el conjunto de nodos del trie donde un prefijo termina. El nodo que posea el m\'aximo de estos valores representar\'a el prefijo desde el cual salga la mayor cantidad de palabras distintas. Esto es, el prefijo m\'as compartido. Para hallarlo, basta recorrer los nodos que representan los prefijos más cortos (es decir, aquellos que representan fin de cadena y que estan más cerca de la raíz) y ver cuál tiene el $C$ más grande.

\subsubsection{Complejidad}
El algoritmo consiste en insertar cada $D_i$ en el \emph{Trie} y actualizar $C_i$ donde corresponda.\\
El \emph{Trie} esta conformado por un nodo raíz, y cada nodo $i$ tiene un \emph{mapa} a sus nodos hijos, un \emph{flag} que indica si es el fin de una cadena o no, y $C_i$.\\
A continuación se adjunta el pseudocódigo de las funciones de inserción de una cadena en un nodo:\\
\begin{algorithm}[H]
	\KwData{$S$ cadena a insertar, $i$ indice de $S$ que se esta insertando en un momento dado, $j$ tamaño máximo de $S$ que se quiere guardar}

	\uIf{$i = j$}{
		Marcar nodo como fin de cadena
	}
	\uElseIf{$i < j$}{
		\uIf{Existe nodo $hijo = [d_1,...,d_i]$}{
			Llamo a $hijo.addWord(S,i+1)$\\
		}
		\uElse{
			Creo un nuevo nodo $child$\\
			Llamo a $hijo.addWord(S,i+1)$\\
			Inserto $hijo$ en el mapa, usando a $s_i$ como clave\\
		}
	}
	Incremento $C$

	\caption{Función \emph{addWord} de los nodos}
\end{algorithm}

Luego, el \emph{Trie} simplemente llama a la funcion $addWord(S_k, 0, |D_k|)$ del nodo raíz.\\
Este algoritmo es recursivo, y en cada llamada, se incrementa el valor de $i$, que puede llegar hasta $j$. Es decir, es equivalente a iterar un ciclo $j$ veces.\\
Lo siguiente que hay que analizar, es el costo de la condición en la línea 4. Ya que existen $256$ símbolos ASCII, y el \emph{mapa} tiene como claves a dichos simbolos, la complejidad de buscar dicho nodo es \O{log(256)}$=$\O{1} (Por propiedades de la \emph{Cota superior}).

Luego, y dado que $j = |D_k|$, insertar una cadena $S_i$ tiene complejidad \O{|D_i|}. Insertar las $A$, entonces, tiene complejidad \O{\displaystyle \sum_{i = 1}^{A} |D_i|}.

Resta ver la búsqueda de $\displaystyle Q = \operatorname*{max}_{i} (C_i)$. Para esto, cada nodo implementa la función \textbf{getMaxAmountOfWordsFromPrefix}:\\
\begin{algorithm}[H]
	\KwResult{$\displaystyle Q = \operatorname*{max}_{i} (C_i)$}

	\uIf{El nodo es de fin de cadena}{
		$maximo \gets C$
	}
	\uElse{
		$maximo \gets 0$
	}
	\For{Cada nodo hijo $hijo$}{
		$maximo \gets max(maximo, hijo.getMaxAmountOfWordsFromPrefix())$
	}
	Devolver $maximo$

	\caption{Función \emph{getMaxAmountOfWordsFromPrefix} de los nodos}
\end{algorithm}

La complejidad de esta función se encuentra en las líneas 5 y 6, dado que las demás operaciones son básicas y por lo tanto, \O{1}.
En la línea 6 se realiza una llamada recursiva, y dicha llamada se realiza con cada uno de los hijos de un nodo. Es decir, se esta realizando una búsqueda \emph{en profundidad} en el árbol.
Dicha búsqueda pasa una única vez por cada nodo en todo el árbol. Si un nodo puede tener como mucho $256$ hijos (uno por cada caracter ASCII), y dado que el árbol tiene $N$ nodos, entonces la complejidad de recorrer dicho árbol es \O{256*N} $ = $ \O{N} (Por propiedades de la \emph{Cota superior}).

Luego, y dado que $N = \displaystyle \sum_{i = 1}^{A} |D_i|$, obtener $Q$ tiene complejidad \O{\displaystyle \sum_{i = 1}^{A} |D_i|}.

Por la suma de dichas operaciones y por propiedades de la \emph{Cota superior} la complejidad total es \O{\displaystyle \sum_{i = 1}^{A} |D_i|}.

\subsection{Puntaje}
El peso otorgado a este ejercicio es:
