\newtheorem*{definition}{Definición}
\newtheorem{lem}{Lema}
\section{Ejercicio 1}
\subsection{El Problema}
Dado dos cadenas de caracteres $W$ y $P$, se desea saber si $P$ es una subcadena de $W$.\\
Formalmente, se define $W = [w_1,...,w_N]$ y $P = [p_1,...,p_k]$, y se desea saber si existe $W_P = [w_q,...,w_t] = P$, con $1 \leq q \leq t \leq N$.\\
El algoritmo debe tener complejidad \O{|W|}.

\subsection{Desarrollo}
Para resolver el problema, se utilizó el algoritmo de \emph{Knuth-Morris-Pratt}.
Por lo tanto, la solución se divide en dos partes:
\begin{itemize}
	\item Calcular los bordes de la cadena $P$
	\item Buscar si existe $W_P$
\end{itemize}

\subsubsection{Cálculo de bordes}
Esta sección explica unicamente cómo se realiza el calculo de bordes y por qué se realiza correctamente. En la sección siguiente se explica como se utiliza para resolver el problema.

Primero, veamos algunas definiciones y propiedades:
\begin{definition}
Se denomina borde de una cadena $S$ a una subcadena que es prefijo y sufijo de $S$.
\end{definition}
\begin{definition}
$P_k \sqsubset P_i \Leftrightarrow P_k$ es prefijo de $P_i$. Analogamente vale $P_k \sqsupset P_i$
\end{definition}

\begin{lem}
Si $T$ es borde de $S$ y $Q$ es borde de $T$, entonces $Q$ es borde de $S$.
\end{lem}
\begin{proof}
Por transitividad de la relación $\sqsubset$, al ser $Q \sqsubset T$ y $T \sqsubset S$, luego $Q \sqsubset S$. Análogamente sucede con los sufijos.
\end{proof}

\begin{lem}
Si $T$ y $Q$ son bordes de $S$ y $|Q|<|T|$, entonces $Q$ es borde de $T$.
\end{lem}
\begin{proof}
Sea $T = [t_1,...,t_N]$, $Q = [q_1,...,q_M]$ y $S = [s_1,...,s_O]$ con $M < N \leq O$, como $Q \sqsubset S$ y $T \sqsubset S$, luego $T = [s_1,..., s_{M-1},s_M,s_{M+1},...,s_N]$ y $Q = [s_1,...,s_M]$. Por lo tanto $Q \sqsubset T$. Análogamente sucede con los sufijos.
\end{proof}

\begin{lem}
Si $T$ y $Q$ son bordes de $S$ y $Q$ es el mayor borde de $T$, entonces $Q$ es el mayor borde de $S$ de longitud menor a $|T|$.
\end{lem}
\begin{proof}
Supongamos que $Q$ no fuera el mayor borde de $S$ de longitud menor a $|T|$, luego existiria un $Q'$ que fuese el mayor borde de $S$ de longitud menor a $|T|$. Si eso ocurriese, $Q'$ sería el mayor borde de $T$. Absurdo, pues $Q$ era el mayor borde de $T$.
\end{proof}

Por comodidad, en adelante llamaremos $P_k$ al prefijo de $P$ de tamaño $k$, y llamaremos $\Pi$ a la estructura que posee las siguientes propiedades:
\begin{itemize}
	\item $\pi_i = max \{k: k < i \wedge P_k \sqsupset P\}$
	\item $\Pi = [\pi_1,...,\pi_{|P|}]$
\end{itemize}
Es decir, $\Pi$ guarda en la \emph{i-ésima} posición, el borde más grande de $P$ que tenga longitud menor o igual a $i$, y es lo que el algoritmo calcula.

\textbf{Correctitud}
A continuación se adjunta un pseudocódigo para facilitar la comprensión de la demostración de correctitud:
\begin{algorithmic}
	\State $P$ cadena a la que calculo los bordes
	\State $\Pi$ arreglo vacío de longitud $|P|$
	\State $j$ tamaño de la cadena máxima encontrada\\
	\State $\Pi[0] \gets 0$
	\State $j \gets 0$
	\For{$i \gets 1...|P|-1$}
		\While{$j > 0 \wedge P[i] \neq P[j]$}
			\State $j \gets \Pi[j-1]$
		\EndWhile
		\If{$P[i] = P[j]$}
			\State $j \gets j+1$
		\EndIf
		\State $\Pi[i] = j$
	\EndFor
	\State Retornar $\Pi$
\end{algorithmic}

Veamos entonces paso a paso.\\

\begin{algorithmic}
  \State $\Pi[0] \gets 0$
  \For{$i \gets 1...|P|-1$}
     \State ...
  \EndFor
\end{algorithmic}
$\Pi[0]$ es $0$ ya que el borde de mayor tamaño del prefijo de tamaño $1$ es $0$ (es decir, la cadena vacía). Luego, se itera la cadena $P$ desde $1$ ya que no es necesario ver el caso del prefijo de tamaño $1$.\\

\begin{algorithmic}
\While{$j > 0 \wedge P[i] \neq P[j]$}
	\State $j \gets \Pi[j-1]$
\EndWhile
\end{algorithmic}

$j$ expresa en cada iteración, el tamaño del mayor borde de $P_i \sqsubset P$, $|P_i| = i$.
Por lo tanto, aquí se intenta extender el borde de longitud $j$ (es decir, el borde de $P_i$) para el prefijo de longitud $P_{i+1}$. Si no se puede extender, se verifica si se puede extender el borde de $P_{i-1}$ y así sucesivamente.\\

\begin{algorithmic}
\If{$P[i] = P[j]$}
	\State $j \gets j+1$
\EndIf
\end{algorithmic}

Si es posible extender el borde de longitud $j$, lo extiendo.\\

\begin{algorithmic}
\State $\Pi[i] = j$
\end{algorithmic}

Agrego en $\Pi$ la longitud del borde de mayor tamaño que pude encontrar, es decir, el borde de mayor tamaño de $P_i$ (puede ser $0$).\\

Al finalizar, se tendrá un arreglo $\Pi$ que cumple las propiedades previamente mencionadas.\\

\hfill\ensuremath{\square}

\textbf{Complejidad}
En cada paso de la iteración
\subsubsection{Complejidad}

\subsection{Puntaje}
El peso otorgado a este ejercicio es:
