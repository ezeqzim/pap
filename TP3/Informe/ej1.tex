\newtheorem*{definition}{Definición}
\newtheorem{lem}{Lema}
\section{Ejercicio 1}
\subsection{El Problema}
Dado dos cadenas de caracteres $W$ y $P$, se desea saber si $P$ es una subcadena de $W$.\\
Formalmente, se define $W = [w_1,...,w_N]$ y $P = [p_1,...,p_k]$, y se desea saber si existe $W_P = [w_q,...,w_t] = P$, con $1 \leq q \leq t \leq N$.\\
El algoritmo debe tener complejidad \O{|W|}.

\subsection{Desarrollo}
Para resolver el problema, se utilizó el algoritmo de \emph{Knuth-Morris-Pratt}.
Por lo tanto, la solución se divide en dos partes:
\begin{itemize}
	\item Cálculo de bordes de la cadena $P$
	\item Búsqueda de $W_P$
\end{itemize}

\subsubsection{Cálculo de bordes de la cadena $P$}
Esta sección explica unicamente cómo se realiza el calculo de bordes y por qué se realiza correctamente. En la sección siguiente se explica como se utiliza para resolver el problema.

Primero, veamos algunas definiciones y propiedades:
\begin{definition}
$P_k \sqsubset P_i \Leftrightarrow P_k$ es prefijo de $P_i$. Analogamente vale $P_k \sqsupset P_i \Leftrightarrow P_k$ es sufijo de $P_i$.
\end{definition}
\begin{definition}
Se denomina borde de una cadena $S$ a una subcadena que es prefijo y sufijo de $S$. Es decir, $Q$ es borde de $S \Leftrightarrow Q \sqsubset S \wedge Q \sqsupset S$
\end{definition}

\begin{lem}
La relación $\sqsubset$ es transitiva.
\end{lem}
\begin{proof}
Sean $A = [a_1,...,a_k]$, $B = [b_1,...,b_n]$, $C = [c_1,...,c_m]$, cadenas tales que $A \sqsubset B$, $B \sqsubset C$, queremos ver si $A \sqsubset C$.\\
Como $A \sqsubset B$, luego $A = [b1,...,b_k]$, y como $B \sqsubset C$, luego $B = [c_1,...,c_n]$. Entonces $A = [c_1,...,c_k]$ y por lo tanto $A \sqsubset C$.
\end{proof}

\begin{lem}
Si $T$ es borde de $S$ y $Q$ es borde de $T$, entonces $Q$ es borde de $S$.
\end{lem}
\begin{proof}
Por \textbf{Lema 1}, al ser $Q \sqsubset T$ y $T \sqsubset S$, luego $Q \sqsubset S$. Análogamente sucede con los sufijos.
\end{proof}

\begin{lem}
Si $T$ y $Q$ son bordes de $S$ y $|Q|<|T|$, entonces $Q$ es borde de $T$.
\end{lem}
\begin{proof}
Sea $T = [t_1,...,t_N]$, $Q = [q_1,...,q_M]$ y $S = [s_1,...,s_O]$ con $M < N < O$, como $Q \sqsubset S$ y $T \sqsubset S$, luego $T = [s_1,..., s_{M-1},s_M,s_{M+1},...,s_N]$ y $Q = [s_1,...,s_M]$. Por lo tanto $Q \sqsubset T$. Análogamente sucede con los sufijos.
\end{proof}

\begin{lem}
Si $T$ y $Q$ son bordes de $S$ y $Q$ es el mayor borde de $T$, entonces $Q$ es el mayor borde de $S$ de longitud menor a $|T|$.
\end{lem}
\begin{proof}
Supongamos que $Q$ no fuera el mayor borde de $S$ de longitud menor a $|T|$, luego existiria un $Q'$ que fuese el mayor borde de $S$ de longitud menor a $|T|$. Ya que $Q'$ es un borde de $S$, eso significa que $Q' \sqsubset S$, y como $|Q'| < |T|$ entonces por el \textbf{Lema 3}, $Q'$ sería el borde de $T$, y al ser $|Q'| > |Q|$, $Q'$ sería el mayor borde de $T$. Absurdo, pues $Q$ era el mayor borde de $T$.
\end{proof}

Por comodidad, en adelante llamaremos $P_k$ al prefijo de $P$ de tamaño $k$, y llamaremos $\Pi$ a la estructura que posee las siguientes propiedades:
\begin{itemize}
	\item $\pi_i = max \{k: k < i \wedge P_k \sqsupset P\} = $ Longitud del mayor borde de $P$ de longitud menor a $i$.
	\item $\Pi = [\pi_1,...,\pi_{|P|}]$
\end{itemize}

\textbf{Correctitud}\\
A continuación se adjunta un pseudocódigo para facilitar la comprensión de la demostración de correctitud:\\
\begin{algorithm}[H]
 \DontPrintSemicolon
 \KwData{$P$ cadena a la que calculo los bordes, 
 $\Pi$ arreglo vacío de longitud $|P|$, 
 $j$ tamaño de la cadena máxima encontrada}
 \KwResult{$\Pi$}
 $\Pi[0] \gets 0$\\
 $j \gets 0$\\
 \For{$i \gets 1...|P|-1$}{
		\While{$j > 0 \wedge P[i] \neq P[j]$}{
			$j \gets \Pi[j-1]$
		}
		\uIf{$P[i] = P[j]$}{
			$j \gets j+1$
		}
		$\Pi[i] = j$
 }
 \caption{Cálculo de $\Pi$}
\end{algorithm}

En las líneas 1-3, $\Pi[0]$ es $0$ ya que el borde de mayor tamaño del prefijo de tamaño $1$ es $0$ (es decir, la cadena vacía). Luego, se itera la cadena $P$ desde $1$ ya que no es necesario ver el caso del prefijo de tamaño $1$.\\
Al comienzo de cada iteración, $j$ expresa el tamaño del mayor borde de $P_{i-1} \sqsubset P$, $|P_{i-1}| = i-1$.
En las líneas 4-6, y por el \textbf{Lema 4}, lo que se intenta es extender el borde de mayor tamaño de entre todos los $P_{k}$, $k < i$, tal que sea borde de $P_i$.\\
Si es posible extender el borde de longitud $j$, lo extiendo (líneas 7-8).\\
En la última línea, agrego en $\Pi$ la longitud del borde de mayor tamaño que pude encontrar, es decir, el borde de mayor tamaño de $P_i$ (puede ser $0$).

Al finalizar, se tendrá un arreglo $\Pi$ que cumple las propiedades previamente mencionadas.\\
\strut\hfill\qedsymbol

\textbf{Complejidad}\\
Dado que el \textbf{for} realiza $|P|$ iteraciones, sólo demostraremos que las operaciones realizadas en el cuerpo del \textbf{for} tienen complejidad \O{1} amortizado, demostrando así que el algoritmo tiene complejidad \O{|P|}.
Veremos que el cuerpo del \textbf{while} se ejecuta como mucho $|P|-2$ veces a lo largo de toda la ejecución del \textbf{for}, pero antes, algunas observaciones sobre $j$.\\
Primero, la línea 2 comienza con $j$ en $0$, y la única forma de incrementar $j$ es en la línea 8, donde se incrementa en $1$, que se ejecuta a lo sumo una vez por cada iteración del \textbf{for}.\\
Segundo, dado que $j < i$ al comienzo del \textbf{for} y que en cada iteración se incrementa el valor de $i$ en $1$, entonces la desigualdad $j < i$ se mantiene a lo largo de toda la ejecución del algoritmo. Por lo tanto, las asignaciónes en las líneas 1 y 9 garantizan que $\pi_i < i$ para todo $i = 1,2,...,|P|-1$, lo que significa que en cada iteración del \textbf{while}, se decrementa el valor de $j$.\\
Tercero, $j$ nunca es negativo.\\
Luego, con todos esos datos, se puede ver que el valor total por el que se puede decrementar $j$ durante la ejecución del \textbf{while} esta acotado por el valor máximo por el que se puede incrementar $j$, que es $|P|-2$, a lo largo de todas las iteraciones del \textbf{for}.
En consecuencia, el \textbf{while} itera a lo sumo $|P|-2$ veces a lo largo de toda la ejecución del \textbf{for}, por lo que su costo amortizado es \O{1}.

Luego, el algoritmo tiene complejidad \O{|P|}.\\
\strut\hfill\qedsymbol

\subsubsection{Búsqueda de $W_P$}
A continuación se adjunta el algoritmo:\\
\begin{algorithm}[H]
 \DontPrintSemicolon
 \KwData{$P$, $W$, 
 $\Pi$ arreglo calculado en la sección anterior, 
 $j$ tamaño de la subcadena de $W$ más grande que es prefijo de $P$}
 \KwResult{El índice de $W$ donde comienza $W_P$, o $-1$ si no existe $W_P$}
 $j \gets 0$\\
 \For{$i \gets 0...|W|-1$}{
		\While{$j > 0 \wedge W[i] \neq P[j]$}{
			$j \gets \Pi[j-1]$
		}
		\If{$W[j] = P[i]$}{
			$j \gets j+1$
		}
		\uIf{$j = |P|$}{
			Devolver $i - j + 1$
		}
 }
 Devolver -1
 \caption{Búsqueda de $W_P$}
\end{algorithm}

Esencialmente, el algoritmo es igual al de cálculo de bordes, con la siguiente diferencia de que en las líneas 3-5, no se estan extendiendo bordes, sino que si el caracter que se esta observando no coincide, en lugar de comenzar de cero, se comienza desde el borde.\\
Luego, si los caracteres son iguales, el tamaño de la subcadena de $W$ más grande que es prefijo de $P$ encontrada hasta el momento se incrementa.
Finalmente, si $j = |P|$, significa que encontré $W_P$, y devuelvo el índice donde comienza.

\textbf{Complejidad}\\
Por el mismo razonamiento que en el algoritmo de \emph{cálculo de bordes de $P$}, se puede observar que el \textbf{while} se ejecuta $|W|-1$ veces a lo largo de toda la ejecución del algoritmo, con lo que el \textbf{while} tiene un costo amortizado de \O{1}. Luego, como el \textbf{for} itera $|W|$ veces, el algoritmo tiene complejidad \O{|W|}.

\subsection{Complejidad}
La complejidad del algoritmo es la suma de las complejidades de cada etapa:
\begin{itemize}
	\item Cálculo de bordes de la cadena $P$: \O{|P|}
	\item Búsqueda de $W_P$: \O{|W|}
\end{itemize}

Por la suma de dichas operaciones y por propiedades de la \emph{Cota superior}, como $|P| \leq |W|$, la complejidad total es \O{|W| + |P|} $ = $ \O{2*|W|} $=$ \O{|W|}.

\subsection{Puntaje}
El peso otorgado a este ejercicio es:
